package main

import (
	"context"
	"errors"
	"io"
	"os"
	"testing"

	"github.com/fatih/color"
	"github.com/google/go-cmp/cmp"
	"github.com/hymkor/go-multiline-ny"
	"github.com/nyaosorg/go-readline-ny"
	"github.com/nyaosorg/go-readline-ny/keys"
	"github.com/stretchr/testify/mock"
)

// MockEditor is an autogenerated mock type for the Editor type
type MockEditor struct {
	mock.Mock
}

// BindKey provides a mock function with given fields: key, cmd
func (_m *MockEditor) BindKey(key keys.Code, cmd readline.Command) error {
	ret := _m.Called(key, cmd)

	if len(ret) == 1 {
		return ret.Error(0)
	}

	return ret.Error(1)
}

// Read provides a mock function with given fields: ctx
func (_m *MockEditor) Read(ctx context.Context) ([]string, error) {
	ret := _m.Called(ctx)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetDefault provides a mock function with given fields: s
func (_m *MockEditor) SetDefault(s []string) {
	_m.Called(s)
}

// SetDefaultColor provides a mock function with given fields: s
func (_m *MockEditor) SetDefaultColor(s string) {
	_m.Called(s)
}

// SetHighlight provides a mock function with given fields: h
func (_m *MockEditor) SetHighlight(h []readline.Highlight) {
	_m.Called(h)
}

// SetHistory provides a mock function with given fields: h
func (_m *MockEditor) SetHistory(h readline.IHistory) {
	_m.Called(h)
}

// SetHistoryCycling provides a mock function with given fields: b
func (_m *MockEditor) SetHistoryCycling(b bool) {
	_m.Called(b)
}

// SetPrompt provides a mock function with given fields: f
func (_m *MockEditor) SetPrompt(f func(w io.Writer, lnum int) (int, error)) {
	_m.Called(f)
}

// SetResetColor provides a mock function with given fields: s
func (_m *MockEditor) SetResetColor(s string) {
	_m.Called(s)
}

// SubmitOnEnterWhen provides a mock function with given fields: f
func (_m *MockEditor) SubmitOnEnterWhen(f func(lines []string, point int) bool) {
	_m.Called(f)
}

// NewLine provides a mock function with given fields: ctx, b
func (_m *MockEditor) NewLine(ctx context.Context, b *readline.Buffer) readline.Result {
	ret := _m.Called(ctx, b)

	var r0 readline.Result
	if rf, ok := ret.Get(0).(func(context.Context, *readline.Buffer) readline.Result); ok {
		r0 = rf(ctx, b)
	} else {
		r0 = ret.Get(0).(readline.Result)
	}

	return r0
}

func Test_readInteractiveInput(t *testing.T) {
	tests := []struct {
		name        string
		mockReadRet []string
		mockReadErr error
		want        *inputStatement
		wantErr     bool
	}{
		{
			name:        "single line input",
			mockReadRet: []string{"SELECT 1"},
			mockReadErr: nil,
			want: &inputStatement{
				Statement:                "SELECT 1",
				StatementWithoutComments: "SELECT 1",
				Delim:                    "",
			},
			wantErr: false,
		},
		{
			name:        "multi-line input",
			mockReadRet: []string{"SELECT", "1"},
			mockReadErr: nil,
			want: &inputStatement{
				Statement:                "SELECT\n1",
				StatementWithoutComments: "SELECT\n1",
				Delim:                    "",
			},
			wantErr: false,
		},
		{
			name:        "EOF error",
			mockReadRet: []string{},
			mockReadErr: io.EOF,
			want:        nil,
			wantErr:     true,
		},
		{
			name:        "other error with no lines",
			mockReadRet: []string{},
			mockReadErr: errors.New("some error"),
			want:        nil,
			wantErr:     true,
		},
		{
			name:        "other error with lines",
			mockReadRet: []string{"SELECT 1"},
			mockReadErr: errors.New("some error"),
			want: &inputStatement{
				Statement:                "SELECT 1",
				StatementWithoutComments: "SELECT 1",
				Delim:                    "",
			},
			wantErr: true,
		},
		{
			name:        "empty input",
			mockReadRet: []string{""},
			mockReadErr: nil,
			want:        nil,
			wantErr:     true, // separateInput will return error for empty input
		},
		{
			name:        "single line with comment",
			mockReadRet: []string{"SELECT 1 -- comment"},
			mockReadErr: nil,
			want: &inputStatement{
				Statement:                "SELECT 1 -- comment",
				StatementWithoutComments: "SELECT 1 ",
				Delim:                    "",
			},
			wantErr: false,
		},
		{
			name:        "multi-line with comments",
			mockReadRet: []string{"SELECT /* multi-line", "comment */ 1"},
			mockReadErr: nil,
			want: &inputStatement{
				Statement:                "SELECT /* multi-line\ncomment */ 1",
				StatementWithoutComments: "SELECT \n1",
				Delim:                    "",
			},
			wantErr: false,
		},
		{
			name:        "leading and trailing whitespace",
			mockReadRet: []string{"  SELECT 1  "},
			mockReadErr: nil,
			want: &inputStatement{
				Statement:                "  SELECT 1  ",
				StatementWithoutComments: "  SELECT 1  ",
				Delim:                    "",
			},
			wantErr: false,
		},
		{
			name:        "only comments",
			mockReadRet: []string{"-- only comment"},
			mockReadErr: nil,
			want: &inputStatement{
				Statement:                "-- only comment",
				StatementWithoutComments: "",
				Delim:                    "",
			},
			wantErr: false,
		},
		{
			name:        "statement with delimiter",
			mockReadRet: []string{"SELECT 1;"},
			mockReadErr: nil,
			want: &inputStatement{
				Statement:                "SELECT 1",
				StatementWithoutComments: "SELECT 1",
				Delim:                    ";",
			},
			wantErr: false,
		},
		{
			name:        "multi-line statement with delimiter",
			mockReadRet: []string{"SELECT", "1;"},
			mockReadErr: nil,
			want: &inputStatement{
				Statement:                "SELECT\n1",
				StatementWithoutComments: "SELECT\n1",
				Delim:                    ";",
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockEditor := new(MockEditor)
			mockEditor.On("Read", mock.Anything).Return(tt.mockReadRet, tt.mockReadErr).Once()
			mockEditor.On("SetDefault", mock.Anything).Return().Maybe() // SetDefault is called after read

			got, err := readInteractiveInput(context.Background(), mockEditor)

			if (err != nil) != tt.wantErr {
				t.Errorf("readInteractiveInput() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if diff := cmp.Diff(tt.want, got); diff != "" {
				t.Errorf("readInteractiveInput() mismatch (-want +got):\n%s", diff)
			}
			mockEditor.AssertExpectations(t)
		})
	}
}

func Test_initializeMultilineEditor(t *testing.T) {
	sysVars := &systemVariables{
		Prompt:      "my_prompt",
		Prompt2:     "my_prompt2",
		HistoryFile: "test_history.txt",
	}
	waitingStatus := ""

	// Create a temporary history file for testing
	historyFile, err := os.CreateTemp("", "test_history_*.txt")
	if err != nil {
		t.Fatalf("failed to create temp history file: %v", err)
	}
	defer os.Remove(historyFile.Name())
	sysVars.HistoryFile = historyFile.Name()
	historyFile.Close()

	getInterpolatedPrompt := func(prompt string) string {
		return "interpolated_" + prompt
	}

	ed, history, err := initializeMultilineEditor(
		&multilineEditorWrapper{&multiline.Editor{}},
		sysVars,
		getInterpolatedPrompt,
		&waitingStatus,
	)
	if err != nil {
		t.Fatalf("initializeMultilineEditor failed: %v", err)
	}

	if ed == nil {
		t.Error("expected editor to be non-nil")
	}
	if history == nil {
		t.Error("expected history to be non-nil")
	}

	// We can't directly assert on MockEditor methods here because initializeMultilineEditor
	// returns a concrete multilineEditorWrapper, not a MockEditor.
	// This test primarily ensures that initializeMultilineEditor doesn't panic
	// and returns non-nil values, and that the history file is handled.
}

func Test_setLineEditor(t *testing.T) {
	tests := []struct {
		name            string
		enableHighlight bool
		noColor         bool
		wantHighlight   bool
	}{
		{
			name:            "enable highlight",
			enableHighlight: true,
			noColor:         false,
			wantHighlight:   true,
		},
		{
			name:            "disable highlight",
			enableHighlight: false,
			noColor:         false,
			wantHighlight:   false,
		},
		{
			name:            "no color",
			enableHighlight: true,
			noColor:         true,
			wantHighlight:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockEditor := new(MockEditor)
			originalNoColor := color.NoColor
			color.NoColor = tt.noColor
			defer func() { color.NoColor = originalNoColor }()

			if tt.wantHighlight {
				mockEditor.On("SetHighlight", mock.Anything).Return().Once()
				mockEditor.On("SetDefaultColor", mock.AnythingOfType("string")).Return().Once()
				mockEditor.On("SetResetColor", mock.AnythingOfType("string")).Return().Once()
			} else {
				mockEditor.On("SetHighlight", ([]readline.Highlight)(nil)).Return().Once()
				mockEditor.On("SetDefaultColor", "").Return().Once()
				mockEditor.On("SetResetColor", "").Return().Once()
			}

			setLineEditor(mockEditor, tt.enableHighlight)
			mockEditor.AssertExpectations(t)
		})
	}
}
