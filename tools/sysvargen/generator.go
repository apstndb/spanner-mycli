package sysvargen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"reflect"
	"strings"
	"text/template"
)

// Generator generates system variable registration code from struct tags.
type Generator struct {
	PackageName string
	Imports     []string
	Variables   []VarDefinition
}

// NewGenerator creates a new code generator.
func NewGenerator(packageName string) *Generator {
	return &Generator{
		PackageName: packageName,
		Imports: []string{
			"github.com/apstndb/spanner-mycli/internal/parser/sysvar",
			"github.com/samber/lo",
		},
	}
}

// ParseFile parses a Go source file and extracts variable definitions.
func (g *Generator) ParseFile(filename string) error {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	var parseErr error
	// Find struct with sysvar tags
	ast.Inspect(file, func(n ast.Node) bool {
		if parseErr != nil {
			return false // Stop traversal on error
		}
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return true
		}

		// Check if this is systemVariables struct
		if typeSpec.Name.Name != "systemVariables" {
			return true
		}

		// Process fields
		for _, field := range structType.Fields.List {
			if field.Tag == nil {
				continue
			}

			tag := reflect.StructTag(strings.Trim(field.Tag.Value, "`"))
			sysvarTag := tag.Get("sysvar")
			if sysvarTag == "" || sysvarTag == "-" {
				continue
			}

			parsedTag, err := ParseSysVarTag(sysvarTag)
			if err != nil {
				continue
			}

			// Skip fields marked as manual
			if parsedTag.Type == "manual" {
				continue
			}

			// Validate type specification
			fieldType := getFieldType(field.Type)
			isUnderscoreField := false
			for _, name := range field.Names {
				if name.Name == "_" {
					isUnderscoreField = true
					break
				}
			}

			if parsedTag.Type == "" && fieldType == reflect.TypeOf(struct{}{}) {
				// Check if it's an underscore field with a getter (computed variables)
				if !isUnderscoreField && (!parsedTag.ReadOnly || parsedTag.Getter == "") {
					// Error: Variable has sysvar tag but no type and we can't infer it
					fieldNames := []string{}
					for _, name := range field.Names {
						fieldNames = append(fieldNames, name.Name)
					}
					parseErr = fmt.Errorf("field %v has sysvar tag but no type specification and type cannot be inferred", fieldNames)
					return false
				}
			}

			// Handle fields (including underscore fields)
			if len(field.Names) == 0 {
				// Anonymous field (embedded struct) - skip
				continue
			}

			for _, name := range field.Names {
				varDef := VarDefinition{
					FieldName:  name.Name,
					FieldType:  getFieldType(field.Type),
					Tag:        parsedTag,
					StructName: typeSpec.Name.Name,
				}
				g.Variables = append(g.Variables, varDef)
			}
		}

		return true
	})

	return parseErr
}

// Generate generates the registration code.
func (g *Generator) Generate() ([]byte, error) {
	tmpl := template.Must(template.New("sysvar").Funcs(template.FuncMap{
		"title":         title,
		"formatAliases": formatAliases,
	}).Parse(codeTemplate))

	var buf bytes.Buffer
	err := tmpl.Execute(&buf, g)
	if err != nil {
		return nil, err
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code with the error for debugging
		return buf.Bytes(), fmt.Errorf("formatting error: %w\n\nGenerated code:\n%s", err, buf.String())
	}
	return formatted, nil
}

// AddImport adds an import to the generated file.
func (g *Generator) AddImport(importPath string) {
	for _, existing := range g.Imports {
		if existing == importPath {
			return
		}
	}
	g.Imports = append(g.Imports, importPath)
}

// AddImportWithAlias adds an import with an alias to the generated file.
func (g *Generator) AddImportWithAlias(alias, importPath string) {
	aliasedImport := fmt.Sprintf("%s %q", alias, importPath)
	for _, existing := range g.Imports {
		if existing == aliasedImport {
			return
		}
	}
	g.Imports = append(g.Imports, aliasedImport)
}

const codeTemplate = `// Code generated by sysvargen; DO NOT EDIT.

package {{.PackageName}}

import (
	"time"
	
	"github.com/apstndb/spanner-mycli/internal/parser/sysvar"
	"github.com/samber/lo"
	
	"cloud.google.com/go/spanner/admin/database/apiv1/databasepb"
	sppb "cloud.google.com/go/spanner/apiv1/spannerpb"
)

// Silence unused import warnings
var (
	_ = time.Time{}
	_ = sysvar.Registry{}
	_ = lo.ToPtr[any]
	_ = databasepb.DatabaseDialect(0)
	_ = sppb.RequestOptions_Priority(0)
)

// registerGeneratedVariables registers system variables defined by struct tags.
// This function is generated from systemVariables struct tags.
func registerGeneratedVariables(registry *sysvar.Registry, sv *systemVariables) {
{{range .Variables}}
	// {{.Tag.Name}}: {{.Tag.Description}}
{{if eq .Tag.Type "unimplemented"}}
	mustRegister(registry, createUnimplementedParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
	))
{{else if .IsUnderscoreField}}
	// Computed variable with custom getter{{if .Tag.Setter}}/setter{{end}}
{{if and .Tag.ReadOnly (not .Tag.Setter)}}
	mustRegister(registry, sysvar.NewReadOnlyStringParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		sv.{{.Tag.Getter}},
	))
{{else}}
	mustRegister(registry, sysvar.NewStringVariableParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		sv.{{.Tag.Getter}},
		sv.{{.Tag.Setter}},
	))
{{end}}
{{else if .Tag.ReadOnly}}
{{if eq .GetParserType "int"}}
	mustRegister(registry, sysvar.NewIntegerVariableParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		{{if .Tag.Getter}}sv.{{.Tag.Getter}}{{else}}sysvar.GetValue(&sv.{{.FieldName}}){{end}},
		nil,      // No setter - read-only
		nil, nil, // No min/max validation needed for read-only
	))
{{else}}
	mustRegister(registry, sysvar.NewReadOnly{{if eq .GetParserType "bool"}}Boolean{{else}}{{.GetParserType | title}}{{end}}Parser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		{{if .Tag.Getter}}sv.{{.Tag.Getter}}{{else}}sysvar.GetValue(&sv.{{.FieldName}}){{end}},
	))
{{end}}
{{else if eq .GetParserType "bool"}}
	mustRegister(registry, sysvar.NewBooleanParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		{{if .Tag.Getter}}sv.{{.Tag.Getter}}{{else}}sysvar.GetValue(&sv.{{.FieldName}}){{end}},
		{{if .Tag.Setter}}sv.{{.Tag.Setter}}{{else}}sysvar.SetValue(&sv.{{.FieldName}}){{end}},
	))
{{else if eq .GetParserType "string"}}
	mustRegister(registry, sysvar.NewStringVariableParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		{{if .Tag.Getter}}sv.{{.Tag.Getter}}{{else}}sysvar.GetValue(&sv.{{.FieldName}}){{end}},
		{{if .Tag.Setter}}sv.{{.Tag.Setter}}{{else}}sysvar.SetValue(&sv.{{.FieldName}}){{end}},
	))
{{else if eq .GetParserType "int"}}
	mustRegister(registry, sysvar.NewIntegerVariableParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		{{if .Tag.Getter}}sv.{{.Tag.Getter}}{{else}}sysvar.GetValue(&sv.{{.FieldName}}){{end}},
		{{if .Tag.Setter}}sv.{{.Tag.Setter}}{{else}}sysvar.SetValue(&sv.{{.FieldName}}){{end}},
		{{if .Tag.Min}}lo.ToPtr(int64({{.Tag.Min}})){{else}}nil{{end}}, {{if .Tag.Max}}lo.ToPtr(int64({{.Tag.Max}})){{else}}nil{{end}},
	))
{{else if eq .Tag.Type "nullable_duration"}}
	mustRegister(registry, sysvar.NewNullableDurationVariableParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		sysvar.GetValue(&sv.{{.FieldName}}),
		{{if .Tag.Setter}}sv.{{.Tag.Setter}}{{else}}sysvar.SetValue(&sv.{{.FieldName}}){{end}},
		{{if .Tag.Min}}lo.ToPtr({{.Tag.Min}}){{else}}nil{{end}}, {{if .Tag.Max}}lo.ToPtr({{.Tag.Max}}){{else}}nil{{end}},
	))
{{else if eq .Tag.Type "nullable_int"}}
	mustRegister(registry, sysvar.NewNullableIntVariableParser(
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		sysvar.GetValue(&sv.{{.FieldName}}),
		{{if .Tag.Setter}}sv.{{.Tag.Setter}}{{else}}sysvar.SetValue(&sv.{{.FieldName}}){{end}},
		{{if .Tag.Min}}lo.ToPtr(int64({{.Tag.Min}})){{else}}nil{{end}}, {{if .Tag.Max}}lo.ToPtr(int64({{.Tag.Max}})){{else}}nil{{end}},
	))
{{else if eq .Tag.Type "proto_enum"}}
	sysvar.RegisterProtobufEnum{{if .Tag.Aliases}}WithAliases{{end}}(registry,
		"{{.Tag.Name}}",
		"{{.Tag.Description}}",
		{{.Tag.ProtoType}}_value,
		"{{.Tag.Prefix}}",
		{{if .Tag.Getter}}sv.{{.Tag.Getter}}{{else}}sysvar.GetValue(&sv.{{.FieldName}}){{end}},
		{{if .Tag.Setter}}sv.{{.Tag.Setter}}{{else}}sysvar.SetValue(&sv.{{.FieldName}}){{end}},
		{{if .Tag.Aliases}}{{formatAliases .Tag.Aliases .Tag.ProtoType}},{{end}}
	)
{{else}}
	// TODO: Implement parser for {{.GetParserType}} type
{{end}}
{{end}}
}
`

// title returns the title case of a string (for template function).
func title(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// formatAliases converts alias string format to Go code
// Input: "ENUM_VALUE1:alias1,alias2;ENUM_VALUE2:alias3"
// Output: "map[ProtoType][]string{ProtoType_ENUM_VALUE1: {"alias1", "alias2"}, ProtoType_ENUM_VALUE2: {"alias3"}}"
func formatAliases(aliasStr string, protoType string) string {
	if aliasStr == "" {
		return ""
	}

	var parts []string
	for _, entry := range strings.Split(aliasStr, ";") {
		if entry == "" {
			continue
		}
		colonIdx := strings.Index(entry, ":")
		if colonIdx == -1 {
			continue
		}
		enumValue := entry[:colonIdx]
		aliasesStr := entry[colonIdx+1:]

		var aliases []string
		for _, alias := range strings.Split(aliasesStr, ",") {
			if alias != "" {
				aliases = append(aliases, fmt.Sprintf(`"%s"`, alias))
			}
		}

		if len(aliases) > 0 || aliasesStr == "" {
			// Handle empty string alias specially
			if aliasesStr == "" {
				aliases = []string{`""`}
			}
			// Use the enum value as-is (it should contain the full qualified name)
			parts = append(parts, fmt.Sprintf("%s: {%s}", enumValue, strings.Join(aliases, ", ")))
		}
	}

	if len(parts) == 0 {
		return ""
	}

	return fmt.Sprintf("map[%s][]string{%s}", protoType, strings.Join(parts, ", "))
}

// getFieldType extracts the reflect.Type from an AST expression.
func getFieldType(expr ast.Expr) reflect.Type {
	// This is a simplified implementation for the proof of concept.
	// In a real implementation, we would need to resolve the actual types.
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "bool":
			return reflect.TypeOf(bool(false))
		case "string":
			return reflect.TypeOf("")
		case "int64":
			return reflect.TypeOf(int64(0))
		case "int":
			return reflect.TypeOf(int(0))
		}
	case *ast.StarExpr:
		// Handle pointer types
		innerType := getFieldType(t.X)
		if innerType != nil {
			return reflect.PointerTo(innerType)
		}
	}
	// Return a placeholder type for unknown types
	return reflect.TypeOf(struct{}{})
}
